<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · LightLattices.jl</title><meta name="title" content="Manual · LightLattices.jl"/><meta property="og:title" content="Manual · LightLattices.jl"/><meta property="twitter:title" content="Manual · LightLattices.jl"/><meta name="description" content="Documentation for LightLattices.jl."/><meta property="og:description" content="Documentation for LightLattices.jl."/><meta property="twitter:description" content="Documentation for LightLattices.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LightLattices.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Contents</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Type-Hierarchy"><span>Type Hierarchy</span></a></li><li><a class="tocitem" href="#Lattice-construction"><span>Lattice construction</span></a></li><li><a class="tocitem" href="#Basis-Cells-and-Indexing"><span>Basis Cells and Indexing</span></a></li><li><a class="tocitem" href="#Lattice-Indexing"><span>Lattice Indexing</span></a></li><li><a class="tocitem" href="#Relative-coordinate"><span>Relative coordinate</span></a></li><li><a class="tocitem" href="#Iteration"><span>Iteration</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../list/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Gregstrq/LightLattices.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Gregstrq/LightLattices.jl/blob/main/docs/src/manual.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><h2 id="Type-Hierarchy"><a class="docs-heading-anchor" href="#Type-Hierarchy">Type Hierarchy</a><a id="Type-Hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Hierarchy" title="Permalink"></a></h2><p>All the types exported by the package are the subtypes of</p><pre><code class="language-julia hljs">abstract type AbstractNodeCollection{D,T} end</code></pre><p>This type describes an arbitrary collection of nodes in <code>D</code>-dimensional space. The coordinates of the nodes are stored internally as instances of <code>SVector{D,T}</code>. Hence, parameter <code>T</code> describes the type used to store the coordinates.</p><p>All the basis-cell types are subtypes of abstract type <code>AbstractCell</code>.</p><pre><code class="language-julia hljs">abstract type AbstractCell{D,T} &lt;: AbstractNodeCollection{D,T} end</code></pre><p>Analogously, we define the supertype for lattices:</p><pre><code class="language-julia hljs">abstract type AbstractLattice{D,T,PB} &lt;: AbstractNodeCollection{D,T} end</code></pre><p>The additional parameter <code>PB</code> can be either <code>true</code> for periodic boundary conditions, or <code>false</code> for free boundary conditions.</p><p>At this point there is only one subtype of <code>AbstractLattice</code>, which is <code>RegularLattice</code>. In the future, I may add additional types do describe, for example, disordered lattices with vacancies.</p><h2 id="Lattice-construction"><a class="docs-heading-anchor" href="#Lattice-construction">Lattice construction</a><a id="Lattice-construction-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-construction" title="Permalink"></a></h2><p>The general constructor for a regular (without disorder) lattice looks like this:</p><pre><code class="language-julia hljs">RegularLattice(lattice_dims::NTuple{D,Int}[, primitive_vecs::SMatrix{D,D,T}, basis_cell::AbstractCell{D,T1}]; periodic = true, label::Union{Symbol,Nothing}=nothing).</code></pre><p>General lattice consists of a basis cell which is translated in space by the primitive vectors of the Bravais Lattice. Thus, the meaning of the entries is the following:</p><ul><li><code>lattice_dims</code> is the tuple specifying the size of the lattice along each of the primitive vectors.</li><li><code>primitive_vecs</code> is the matrix, which columns are the primitive vectors of the underlying Bravais lattice.</li><li><code>basis_cell</code> specifies the collection of nodes which is used as the basis cell of the lattice.</li><li><code>periodic</code> specifies the boundary conditions: <code>true</code> for periodic, <code>false</code> for free boundary conditions.</li><li><code>label</code> is either <code>nothing</code> or a <code>Symbol</code>; it is a label to refer to the lattice (may be useful to automatically generate the name for the computation which uses particular lattice).</li></ul><div class="admonition is-info" id="Note-d5631bc94c7daa71"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d5631bc94c7daa71" title="Permalink"></a></header><div class="admonition-body"><p>The variables <code>primitive_vecs</code> and <code>basis_cell</code> can use different internal types to store coordinates. However, when the lattice is constructed, they are promoted to the single type.</p><div class="admonition is-warning" id="Warning-41ec42c87d793eb0"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-41ec42c87d793eb0" title="Permalink"></a></header><div class="admonition-body"><p>You should not mix dimensionful and dimensionless types. The promotion would lead to an error in this case. This is made intentionally.</p></div></div></div></div><h3 id="Convenient-constructors"><a class="docs-heading-anchor" href="#Convenient-constructors">Convenient constructors</a><a id="Convenient-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Convenient-constructors" title="Permalink"></a></h3><p>If the variable <code>basis_cell</code> is omitted, it is assumed that basis cell is trivial, i.e. consisting of a single node. If <code>primitive_vecs</code> is omitted as well, hypercubic lattice is constructed. Instead of basis, one can specify the lattice spacing in this case:</p><pre><code class="language-julia hljs">RegularLattice(lattice_dims::NTuple{D,Int}[, a::Number = 1]; label = :cubic, periodic = true)</code></pre><h2 id="Basis-Cells-and-Indexing"><a class="docs-heading-anchor" href="#Basis-Cells-and-Indexing">Basis Cells and Indexing</a><a id="Basis-Cells-and-Indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-Cells-and-Indexing" title="Permalink"></a></h2><p>There are three types of basis cells: <code>HomogeneousCell</code>, <code>TrivialCell</code>, <code>InhomogeneousCell</code>.</p><h3 id="HomogeneousCell"><a class="docs-heading-anchor" href="#HomogeneousCell"><code>HomogeneousCell</code></a><a id="HomogeneousCell-1"></a><a class="docs-heading-anchor-permalink" href="#HomogeneousCell" title="Permalink"></a></h3><p>This type is used when there is no distinction between the nodes of the cell. The general constructor looks like</p><pre><code class="language-julia hljs">HomogeneousCell(node_coordinates::Vector; label::Union{Symbol,Nothing}=nothing)</code></pre><p>where <code>node_coordinates</code> specifies the coordinates of the nodes. The coordinates can be specified either as <code>SVector</code>s, <code>Vector</code>s or <code>NTuple</code>s of same element type and length. Under the hood, coordinates are converted to <code>SVector</code>s.</p><p>One can access the coordinate of the <span>$i$</span>-th node as</p><pre><code class="language-julia hljs">cell[i]</code></pre><h3 id="TrivialCell"><a class="docs-heading-anchor" href="#TrivialCell"><code>TrivialCell</code></a><a id="TrivialCell-1"></a><a class="docs-heading-anchor-permalink" href="#TrivialCell" title="Permalink"></a></h3><p><code>TrivialCell</code> is used by default when no basis cell is specified. It corresponds to a basis cell with single node.</p><p>For consistency of interface, <code>TrivialCell</code> behaves like a <code>HomogeneousCell</code> with single node, which has zero coordinates. One can even index into it:</p><pre><code class="language-julia hljs">getindex(::TrivialCell{D,T}, 1) = zero(SVector{D,T})</code></pre><h3 id="InhomogeneousCell"><a class="docs-heading-anchor" href="#InhomogeneousCell"><code>InhomogeneousCell</code></a><a id="InhomogeneousCell-1"></a><a class="docs-heading-anchor-permalink" href="#InhomogeneousCell" title="Permalink"></a></h3><p>This type is useful if one needs to distinguish between the several groups of nodes.</p><p>For example, one can consider a crystal consisting of several types of nuclei, let&#39;s say, &quot;A&quot; and &quot;B&quot;. Then, if one needs to get the coordinate of the <span>$i$</span>-th nuclei of type &quot;B&quot; inside the basis cell, one calls</p><pre><code class="language-julia hljs">cell[i, 2]</code></pre><p>Generally, if one needs to access the coordinate of <code>ic</code>-th node inside <code>ig</code>-th group, it is done by</p><pre><code class="language-julia hljs">cell[ic, ig]</code></pre><div class="admonition is-info" id="Note-57e8c8f9bf9a7563"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-57e8c8f9bf9a7563" title="Permalink"></a></header><div class="admonition-body"><p>If one does not care about the groups, one can index into <code>InhomogeneousCell</code> as if it was a <code>HomogeneousCell</code>:</p><pre><code class="language-julia hljs">cell[ic]</code></pre><p>This works with lattice indexing as well.</p></div></div><p>The general constructor for the type is</p><pre><code class="language-julia hljs">InhomogeneousCell(group1_coordinates::Vector, group2_coordinates::Vector, other_group_coordinates...; label=nothing).</code></pre><h2 id="Lattice-Indexing"><a class="docs-heading-anchor" href="#Lattice-Indexing">Lattice Indexing</a><a id="Lattice-Indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-Indexing" title="Permalink"></a></h2><h3 id="Default-style"><a class="docs-heading-anchor" href="#Default-style">Default style</a><a id="Default-style-1"></a><a class="docs-heading-anchor-permalink" href="#Default-style" title="Permalink"></a></h3><p>For <code>D</code>-dimensional lattice, the default style of indexing is</p><pre><code class="language-julia hljs">lattice[I::CartesianIndex{D}, Ic...]</code></pre><p>Here, <code>I</code> is the index of the cell, and <code>Ic...</code> specifies the position inside that cell. To be precise,</p><ul><li>in the case of <code>TrivialCell</code>, the default indexing is</li></ul><pre><code class="language-julia hljs">lattice[I::CartesianIndex{D}]</code></pre><ul><li>in the case of <code>HomogeneousCell</code>, it is</li></ul><pre><code class="language-julia hljs">lattice[I::CartesianIndex{D}, ic::Int]</code></pre><ul><li>in the case of <code>InhomogeneousCell</code>, it is</li></ul><pre><code class="language-julia hljs">lattice[I::CartesianIndex{D}, ic::Int, ig::Int]</code></pre><div class="admonition is-info" id="Note-e38ca127654d0"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-e38ca127654d0" title="Permalink"></a></header><div class="admonition-body"><p>One can always index into lattice as if it has a <code>HomogeneousCell</code> basis cell, i.e., using the default style for lattices with <code>HomogeneousCell</code> basis cell.</p></div></div><h3 id="Alternative-style"><a class="docs-heading-anchor" href="#Alternative-style">Alternative style</a><a id="Alternative-style-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-style" title="Permalink"></a></h3><p>The alternative style of indexing is to splat <code>I</code> and <code>Ic</code> into single tuple. For example, we can index into <span>$3$</span>-dimensional lattice</p><ul><li>with <code>TrivialCell</code> as</li></ul><pre><code class="language-julia hljs">lattice[x::Int, y::Int, z::Int]</code></pre><ul><li>with <code>HomogeneousCell</code> as</li></ul><pre><code class="language-julia hljs">lattice[x::Int, y::Int, z::Int, ic::Int]</code></pre><ul><li>with <code>InhomogeneousCell</code> as</li></ul><pre><code class="language-julia hljs">lattice[x::Int, y::Int, z::Int, ic::Int, ig::Int]</code></pre><div class="admonition is-info" id="Note-31b0c53c590288b8"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-31b0c53c590288b8" title="Permalink"></a></header><div class="admonition-body"><p>With alternative indexing, one can again use the style for lattices with <code>HomogeneousCell</code> basis cell for lattices with other types of basis cell. </p></div></div><h3 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h3><p>For the lattice with free boundary conditions, the boundschecking is performed both for index of the cell and the index inside the cell.</p><p>In the case of the lattice with periodic boundary conditions, the boundschecking is only applied to the index inside the cell. If the cell index is outside the boundaries, it is simply translated back inside the boundaries.</p><p>As an example, let us consider two cubic lattices of similar size, but with different boundary conditions:</p><pre><code class="language-julia hljs">cubic_free = RegularLattice((11,11,11); periodic = false)

cubic_periodic = RegularLattice((11,11,11); periodic = true)</code></pre><p>For the former lattice, <code>cubic_free[12,12,12]</code> leads to <code>BoundsError</code>. For the latter lattice, <code>cubic_periodic[12,12,12]</code> is equivalent to <code>cubic_periodic[1,1,1]</code>.</p><h2 id="Relative-coordinate"><a class="docs-heading-anchor" href="#Relative-coordinate">Relative coordinate</a><a id="Relative-coordinate-1"></a><a class="docs-heading-anchor-permalink" href="#Relative-coordinate" title="Permalink"></a></h2><p>The package exports the function</p><pre><code class="language-julia hljs">relative_coordinate(collection::AbstractNodeCollection, I1, I2)</code></pre><p>which returns the coordinate of node <code>I1</code> relative to node <code>I2</code>. The format of the indices <code>I1</code> and <code>I2</code> depends on particular type of the collection (they should correspond to the default style of index). You can find default style of indexing for basis cells in <a href="#Basis-Cells-and-Indexing">Basis Cells and Indexing</a> section. The default styles for lattices are listed in subsection <a href="#Default-style">Default style</a></p><div class="admonition is-info" id="Note-790588f6a3d7de4"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-790588f6a3d7de4" title="Permalink"></a></header><div class="admonition-body"><p>If the index in default style is multicomponent, it is passed into <code>relative_coordinate</code> as a Tuple. Single <code>Int</code> or single <code>CartesianIndex{D}</code> are considered single-component.</p></div></div><h3 id="Lattices-with-periodic-boundaries"><a class="docs-heading-anchor" href="#Lattices-with-periodic-boundaries">Lattices with periodic boundaries</a><a id="Lattices-with-periodic-boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Lattices-with-periodic-boundaries" title="Permalink"></a></h3><p>In the case of the lattice with periodic boundary conditions, one is interested in the shortest connecting vector for two nodes. The meaning of the shortest here is the following. One can translate the lattice periodically in all directions. If one specifies the node, the translation of the lattice produces the images of this specific node. The shortest connecting vector is determined by picking the first node or its image, so that the distance to the second node is minimal. In the case of the lattice with non-trivial cell, it is possible that this procedure is ambiguous: there can be several connecting vectors with the same minimal length (these vectors are related by symmetry).</p><p>In this package, I resolve this ambiguity by using a specific heuristic. Let me consider two nodes with indices <code>(I1, Ic1...)</code> and <code>(I2, Ic2...)</code>. Here, <code>I1</code> and <code>I2</code> are <code>CartesianIndice</code>s of cells, <code>Ic1</code> and <code>Ic2</code> are indices inside the cells. In the case of a lattice with periodic boundary conditions <code>relative_coordinate</code> returns</p><pre><code class="language-julia hljs">lattice[Ic1 + central_cell - Ic2, Ic1...] - lattice[central_cell, Ic2...]</code></pre><p>Here, <code>central_cell</code> is literally the index of the central cell of the lattice:</p><pre><code class="language-julia hljs">central_cell = CartesianIndex(div.(lattice_dims, 2) .+ 1)</code></pre><p>In reality, it is central only if lattice dimensions are all odd. In the case of even dimensions it gives the index of one of several central cells.</p><p>The idea is quite simple: both <code>Ic1</code> and <code>Ic2</code> are translated by the same amount so that <code>Ic2</code> points to the central cell. Then, <code>Ic1</code> is translated back inside the boundaries (it is performed implicitly while indexing into lattice). Finally, the resulting indices are used to compute the relative coordinate.</p><div class="admonition is-info" id="Note-c8ac8ee84216541e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-c8ac8ee84216541e" title="Permalink"></a></header><div class="admonition-body"><p>This heuristic satisfies the important property of reciprocity:</p><pre><code class="language-julia hljs">relative_coordinate(lattice, I1, I2) == - relative_coordinate(lattice, I2, I1)</code></pre></div></div><h2 id="Iteration"><a class="docs-heading-anchor" href="#Iteration">Iteration</a><a id="Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration" title="Permalink"></a></h2><p>The package provides <code>eachindex</code> implementation for all exported cell and lattice types. For cells, the iteration order is as follows: first nodes inside a group, then the groups themselves (if there are any groups). For lattices, the iteration over the basis cell indices is preceded by th iteration over lattice indices.</p><p>In addition, to that, the package provides a function to compare the indices:</p><pre><code class="language-julia hljs">takes_precedence(I1, I2)</code></pre><p>This function returns <code>true</code> if index <code>I1</code> occurs before index <code>I2</code> in the iteration order. Correspondingly, it returns <code>false</code> otherwise.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Contents</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 3 August 2025 19:57">Sunday 3 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
